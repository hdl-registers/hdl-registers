.. _generator_python:

Python code generator
=====================

The Python code generator creates an accessor class for reading, writing and printing register and
field values.
The class will have a named method for each of these operations on each register and field.
The methods use native Python types (e.g. ``int``, ``float``, ``Enum``) to represent values that
are read or written.
This means that the user never has to do any bit slicing or casting.

* :class:`.PythonPickleGenerator` saves a Python :py:mod:`pickle` file containing the
  :class:`.RegisterList`, along with a small wrapper file to recreate the object.
* :class:`.PythonAccessorGenerator` creates a Python class with methods to read/write/print each
  register and field.

These can be used in a Python-based system test environment to conveniently perform register
read/writes on the target device.

The artifacts are generated like this:

.. literalinclude:: py/generator_python.py
   :caption: Python code that parses the example TOML file and generates Python register artifacts.
   :language: Python
   :linenos:
   :lines: 10-


Pickle code
-----------

The script below is generated by the :class:`.PythonPickleGenerator` and can be used to re-create
the :class:`.RegisterList` object from the Python :py:mod:`pickle` file.

.. collapse:: Click to expand/collapse code.

  .. literalinclude:: ../../../../generated/sphinx_rst/register_code/generator/generator_python/example.py
     :caption: Example Python pickle re-creation script
     :language: Python
     :linenos:

|


Accessor code
-------------

The class :ref:`below <python_accessor_code>` is generated by the :class:`.PythonAccessorGenerator`
for performing register and field operations on a target device.
Interesting things to notice:

1. Register read/write operations use a generated Python :py:mod:`dataclass <dataclasses>` to
   represent a register with field value members.
   See e.g. ``read_config`` and ``write_config``, and the ``ExampleConfigValue`` type in
   the :ref:`generated code <python_accessor_code>`.

2. Field values are represented using native Python types.

  a. A :ref:`bit field <field_bit>` is represented as a Python ``int``.

  b. A :ref:`bit vector field <field_bit_vector>` WITHOUT fractional bits is represented as a
     Python ``int`` (whether signed or unsigned).

  c. A :ref:`bit vector field <field_bit_vector>` WITH fractional bits is represented as a
     Python ``float`` (whether signed or unsigned).

  d. An :ref:`enumeration field <field_enumeration>` is represented using a custom Python
     :py:mod:`Enum <enum>` type.
     See e.g. ``ExampleConfigValue.Direction``.

  e. An :ref:`integer field <field_integer>`, whether signed or unsigned, is represented as a
     Python ``int``.

3. In cases where the register has no fields, the read and write use a plain integer instead.
   See e.g. ``read_status``.

4. Each writeable register has methods to write

   a. The entire register value (e.g. ``write_config``), which takes a dataclass value as argument.

   b. Individual field values (e.g. ``write_config_direction``), which takes the native Python
      field representation as argument.

   Field write methods will either read-modify-write the register or plain write, depending on what
   the :ref:`register mode <basic_feature_register_modes>` allows.


Printing values
_______________

Each register value type has a ``__str__`` method that can be used to print the value in a
human-readable way.
The class also implements the ``print_registers`` method, which will print all registers.
Click the button below to expand an example printout from a unit test.

.. collapse:: Click to expand/collapse example.

  .. code-block:: none
    :caption: Example ``print_registers`` result.

    Register 'reg_array_a[2].reg_wpulse' .......................................... (index 48, address 192):
      Not readable.

    Register 'reg_array_a[2].reg_r_wpulse' ........................................ (index 49, address 196):
      bit_aa0: 0
      bit_aa1: 1
      unsigned_aa: 6 (hexadecimal 6, binary 0110)
      signed_aa: -7 (unsigned decimal 9, hexadecimal 9, binary 1001)
      ufixed_aa: 3.0 (unsigned decimal 12, hexadecimal C, binary 1100)
      sfixed_aa: -0.375 (unsigned decimal 13, hexadecimal D, binary 1101)
      enumeration_aa: ELEMENT_AA2 (2)
      uint_aa: 10 (hexadecimal A, binary 1010)
      sint_aa: -5 (unsigned decimal 27, hexadecimal 1B, binary 1_1011)

|

Note how only readable registers are printed.
Field values are present firstly as their native type, but also as their decimal, hexadecimal and
binary encodings.


Register accessor interface
___________________________

The :ref:`code <python_accessor_code>` generated by :class:`.PythonAccessorGenerator` performs
the address calculation, mode logic, bit slicing, and type casting for you.
It can not, however, implement the actual reading and writing of register values on your
target device.
This must be implemented by the user, given the methods of access that are available
in your environment (SSH, telnet, UART, etc).
Hdl-registers can not implement this in a generic way this is useful in all environments, since
device setup is so different in different projects.

The :ref:`class constructor <python_accessor_code>` takes a ``register_accessor`` argument of type
:class:`.PythonRegisterAccessorInterface`.
This object must be constructed by the user, must inherit the
:class:`.PythonRegisterAccessorInterface`, and must implement the ``read_register`` and
``write_register`` methods.
See the :class:`API documentation <.PythonRegisterAccessorInterface>` for more details.


.. _python_accessor_code:

Code
____

.. literalinclude:: ../../../../generated/sphinx_rst/register_code/generator/generator_python/example_accessor.py
   :caption: Example Python accessor class
   :language: Python
   :linenos:
